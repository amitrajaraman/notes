\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{cs-305}

\begin{document}

\thispagestyle{empty}
\titleBC

% \setcounter{section}{-1}

\section{Introduction}

	\subsection{Overview}

		What is a computer? It includes anything from a smartphone to an iPad to a data center. Let us delay what ``computer architecture'' means to the end of the course and try to figure out what it should mean for now. Historically, the heavy lifting is done by the computer architecture. The computing stack is as follows: we have problems, for which we design algorithms, which we implement in programming languages/compilers, which are run using an operating/database/network system, which require computer architecture to run (which is the focus of this course).

		Most software companies nowadays such as Microsoft, Amazon, and Facebook build their own processors or chips.

		Since the dawn of time (1946 for our purposes), any computer has 5 components -- the processor which consists of control and datapath, memory, input, and output. Computer architecture changes over time depending on our requirements.

		Abstractions are useful if we only care about \emph{what} we want to do. But if we want to know how or why we are doing something, they are all but useless -- so we aim to break them in this course.\\

		\textbf{MIPS} is a simple yet expressive instruction set architecture (ISA) which we shall use in this course. It is used even today in embedded devices, routers, modems etc. The ISA provides an interface between hardware and software -- it veils complexity through a set of simple instructions.\\
		For example, \texttt{a = b + c} might be the C code, which gets converted to \texttt{add \$1, \$2, \$3} (assembly language) by the compiler, which in turn gets converted to some binary string (machine language) by the assembler.\\
		Operands can be located either in registers or in memory. Registers (32-bit addresses) are closer to the processor so are easier and cheaper to access, while memory (DRAM addresses) is costlier to access. However, registers are limited -- we don't have a lot of them.

	\subsection{Introduction to MIPS}

		In 1949, \emph{EDSAC} had only 18 machine instructions. Today in 2021, x86 has over 1500 such instructions. Why do we need these instructions? Programmers must know what the processor can/cannot do, and the processor knows what it should do. In a world with no such instructions, we would have to communicate tedious binary strings to perform simple tasks. 

		Let us zoom into the processor for a moment. We have a set of registers (tens of them -- 32 or 64 for example) and an Arithmetic/Logic Unit (ALU). The processor communicates with the memory through the \emph{address bus} (the processor sends the address to the memory) and the \emph{data bus} (the memory sends data to the processor). The processor can directly access the data of registers, whereas memory has to be accessed in two steps (using the two buses).

		Let us look at the most basic operation of MIPS: \textbf{\texttt{add}}. In \texttt{add \$0, \$1, \$2}, \texttt{add} is the operation, \texttt{\$0} is the destination, and \texttt{\$1} and \texttt{\$2} are the sources. Each of these three (\texttt{\$n}) refers to a certain register. Most ALU operations in MIPS have two sources and one destination.

		If we want to do \texttt{a = b + c - d}, we can do
		\begin{verbatim}
			add $t0, $s1, $s2
			sub $s0, $t0, $s3
		\end{verbatim}
		Here, \texttt{\$t0} is a temporary register. We also use constants in our program. For this, MIPS have instructions that end with \texttt{i}, where \texttt{i} means ``immediate''. For example, \texttt{addi \$s0, \$s0, 10} adds 10 (the \texttt{i} refers to the fact that 10 is a constant). The constants are represented in 16-bit 2s complement form.

		We do not need \texttt{subi} since we can use an appropriate constant with \textbf{\texttt{addi}} instead.

		\texttt{\$0} or \texttt{\$zero} is a special register that contains zero. In particular, \texttt{a=b} becomes \texttt{add \$s1, \$s2, \$zero}. This begs the question, why would we add when can move instead? This leads to the \emph{pseudo-instruction} \texttt{move \$s1, \$s2}. This is not an actual instruction and is merely used for programming convenience.

		Let us next look at a couple of logical operations:
		\begin{itemize}
			\item \textbf{\texttt{sll}} shifts to the left,
			\item \textbf{\texttt{srl}} shifts to the right, and
			\item \textbf{\texttt{and}}, \textbf{\texttt{or}}, \textbf{\texttt{nor}}, \textbf{\texttt{andi}}, and \textbf{\texttt{ori}} mean the usual thing.
		\end{itemize}
		Interestingly, there is no \texttt{not} instruction, we instead use \texttt{nor} with one operand as \texttt{0}. When we are dealing with these instructions, one must understand that we are dealing with 32 raw bits, not a 32-bit number. 

		Now, how would we store a 32-bit constant in a 32-bit register (the instructions so far take 16-bit numbers)? The operation \textbf{\texttt{lui}} loads the first 16 bits of a 32-bit number into a register setting the lower bits all 0. We then perform an \texttt{or} of this register with the other 16 bits. So, if we wanted \texttt{\$t0} to store the 32-bit constant \texttt{10101010 10101010 11110000 1111000}, then we can do
		\begin{verbatim}
			lui $t0, 0xAAAA
			ori $t0, $t0, 0xF0F0
		\end{verbatim}
		Note that all constants used in the operations are only 16 bits long.

	\subsection{Operations on Memory}

		Before 1944, memory only stored the data required to perform an operation. So, the stored program as the binary is stored in memory. Von Neumann then came up with the idea to store instructions in memory as well. We refer to a ``word'' by a 4-byte binary string. Memory is then just a collection of words. The \textit{program counter} (PC) or \textit{instruction pointer} (IP) is a special register that stores the address of the instruction. So, if we have a 32-bit processor and the address are of width 32 bits as well, the processor fetches PC, PC+4, PC+8,$\ldots$ sequentially.

		When we want some operation done,
		\begin{enumerate}
			\item the processor gets the instruction from memory,
			\item the ALU demands the data using the address through the address bus,
			\item the memory responds with the data through the data bus, and
			\item the ALU performs the operation.
		\end{enumerate}
		We can also think of a step 0 where a request is sent based on the PC itself.

		% Suppose we have a program with only three instructions: \texttt{PCX} which points to \texttt{lw}, \texttt{PCY} which points to \texttt{add}, and \texttt{PCZ} which points to \texttt{lui}. If stored sequentially, PY=PCX+4 and PCZ=PCY+4.

		Why do we use memory and not registers? Registers are fast because they are limited -- the more registers we have, the higher the access time becomes. We shall look at this in more detail later.\\

		How do we access data from memory?\\
		The two primary instructions for this are \textbf{\texttt{lw}} (\texttt{l}oad \texttt{w}ord) and \textbf{\texttt{sw}} (\texttt{s}tore \texttt{w}ord). The former loads data from the memory to the register, while the latter writes data from the registers to the memory.\\
		For example, \texttt{lw \$t0, 1(\$a0)} performs \texttt{\$t0 = Memory[\$a0+1]}. The processor sends a ``load request'' to the address \texttt{\$a0+1} and the memory responds with the data at that address. Similarly, \texttt{sw \$t0, 1(\$a0)} does \texttt{Memory[\$a0+1] = \$t0}.

		When we do an \texttt{lw} operation, there are two fetches from memory -- one for the instruction itself and another for the data. When we do an \texttt{add} operation on the other hand, there is only one fetch since there is no memory access.

		% Recall that the load immediate (\texttt{lui}) operation is not a load from memory since we use a constant.

		Let us now move on to decision-making instructions.
		\begin{itemize}
			\item \textbf{\texttt{beq}} (\texttt{b}ranch \texttt{eq}uals to): If we do \texttt{beq \$t0, \$t1, L1}, the PC goes to ``label'' \texttt{L1} (\texttt{goto L1}) if \texttt{\$t0} and \texttt{\$t1} are equal.% We shall define what a label is later.

			\item \textbf{\texttt{bne}} (\texttt{b}ranch \texttt{n}ot \texttt{e}quals to): If we do \texttt{bne \$t0, \$t1, L1}, the PC goes to label \texttt{L1} if \texttt{\$t0} and \texttt{\$t1} are \emph{not} equal. We shall define what a label is later.

			\item \textbf{\texttt{slt}} (\texttt{set} on \texttt{l}ess \texttt{t}han): If \texttt{t1} and \texttt{t2} contain $a$ and $b$, then \texttt{slt \$t3, \$t1, \$t2} does the following: if $a < b$, it sets the content of \texttt{t3} to $1$ and otherwise, it sets the content to $0$.    
			We also have \texttt{slti}, where one of the operands is a constant.
		\end{itemize}

		Next, we look at unconditional jumps (as opposed to the conditional jumps we just looked at):

		\begin{itemize}
			\item \textbf{\texttt{j}} (\texttt{j}ump): It allows us to jump to a label. This instruction loads an immediate into the PC -- it can be specified by either an offset or the label (the assembler converts this label to an offset).

			Now, suppose are running some C code wherein we call a function, and return after the successful running of the function. How do we return to the appropriate place after the code finishes running?

			\item \texttt{\textbf{jal}} and \texttt{jr} (\texttt{j}ump \texttt{a}nd \texttt{l}ink and \texttt{j}ump \texttt{r}egister): \texttt{jal L1} jumps to the label \texttt{L1} which has to be instruction to be executed next and saves the address of the next instruction (PC + 4)\footnote{One might expect to jump to PC+4 instead. We shall look at the reason for the 8 later.} in \texttt{\$ra}. \texttt{ra} is a special register that stores the return address. \texttt{jr \$ra} then returns to the required spot after execution of the intermediate function.
		\end{itemize}

		It is possible that some code in the main function accesses, say, register \texttt{\$R2} and something in a called function accesses register \texttt{\$R2} as well. How do we coordinate this? What data is really accessed when we access a certain register (does the function then attempt to access main's data?) What is the protocol using which the caller and callee interact? MIPS allows \emph{four} arguments to be passed from the caller to the callee while using \texttt{jal}, which uses registers \texttt{\$a0} through \texttt{\$a3}. A callee returns upto two values to the caller, using registers \texttt{\$v0} and \texttt{\$v1}.\\
		How does this work out when we have nested functions? The data transferred by the second function to the third in the \texttt{\$a0} to \texttt{\$a3} registers will overwrite the data transferred by the first to the second! Similarly, the value of \texttt{\$ra} changes as well, so how do we go back to the original function and fix these issues? We might think of allotting some registers to be used by the caller and some to be used by the callee. Unfortunately, the callee does not know the registers used by callers (which may be many in number), and the caller does not know the callee's plan either. We can't just allot new registers because we do not know how many nested functions are there, and we only have a limited number of registers: 
		In MIPS, there are 32 registers:
		\begin{center}
		\begin{tabular}{|l|c|}
			Registers & Number \\ \hline
			\texttt{\$Zero} & 1 \\
			Return value registers (\texttt{\$v0}, \texttt{\$v1}) & 2 \\
			Argument registers (\texttt{\$a0} to \texttt{\$a3}) & 4 \\
			Return address (\texttt{\$ra}) & 1 \\
			Saved registers (\texttt{\$s0} to \texttt{\$s7}) & 8 \\
			Temporary registers (\texttt{\$t0} to \texttt{\$t9}) & 10 \\
			Global pointer (\texttt{\$gp}) & 1 \\
			Stack pointer (\texttt{\$sp}) & 1 \\
			Frame pointer (\texttt{\$fp} or \texttt{\$t10}) & 1 \\
			OS kernel activities (\texttt{\$k0} and \texttt{\$k1}) & 2 \\
			Assembler (\texttt{\$at}) & 1
		\end{tabular}
		\end{center}

		The above described problem is known as \textbf{register spilling}, we are running out of registers to use.\\
		So where else can we store data? The only other place to store data at all is the memory, so that is what we shall choose!\\
		The stack pointer (\texttt{\$sp}) points to the stack, which is part of the DRAM. The stack is private to each function call to ensure that other functions do not overwrite its data. \texttt{\$sp} points to the address where the stack \emph{ends}. The stack grows \emph{downwards}. When we push something to the stack, we decrement the \texttt{\$sp} by 4 and store the register content in the appropriate place in memory.\\

		\texttt{\$t0} through \texttt{\$t9} (registers R8 to R15, R24, and R25) are caller-saved registers. Their values are not preserved across function calls and are said to be \emph{call-clobbered}.\\
		\texttt{\$s0} through \texttt{\$s9} (registers R16 to R23) on the other hand are callee-saved registers. Their values are maintained across function calls and said to be \emph{call-preserved}.\\
		Are \texttt{\$sp} and \texttt{\$ra} caller- or callee-saved registers?\\

		To handle register spilling, MIPS stores the data of the registers in the stack and moves on. After the function is finished, we pop the data off the stack and change the register content back to the initial state. How does this work in MIPS? To save data to a register, we do
		\begin{verbatim}
			addi $sp, $sp, -4
			sw R4, $sp
		\end{verbatim}
		and to restore data,
		\begin{verbatim}
			lw R4, $sp
			addi $sp, $sp, 4
		\end{verbatim}
		So when we call a function, all the relevant data (\texttt{\$ra} in particular) is stored into the stack so that we know where to return to.

		The stack is also used to store local variables and data structures for a function along with the return addresses. To look at these, we have a \emph{frame pointer} (\texttt{\$fp}). It points to the highest address (on the downward growing stack) in the procedure frame and is used to look at local variables and saved registers. It stays there throughout the procedure while the stack pointer moves around. This is just to make life easier for the compiler/programmer. Technically, we do not require it and can make do with the stack pointer alone (with a suitable offset), but that is very inconvenient.


\end{document}