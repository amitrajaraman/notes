\section{Turing Machines}

\subsection{Introduction}

	Before we get to the more rigorous part of Turing machines, we require some setup. \\
	Recall that a set is said to be \emph{countable} if it is in bijection with $\N$. For example, one may show that $\Z$, $\N^2$, and in general, $\N^k$ (for any fixed $k \ge 1$) is countable.\\
	One may also show that a countable union of countable sets is countable. A consequence of this is that the set of all finite sequences in $\N$ is countable. However, it turns out that the set of all (countable) sequences in $\N$ is not countable!\\
	Countable sets are also often referred to as ``enumerable''.\\

	Inspired by this but with a more computer-science flavour, one may define the following.

	\begin{fdef}
		A set $S$ is said to be \emph{computably enumerable} if there exists an algorithm that enumerates the members of $S$, that is, a sequence $s_1, s_2, s_3, \cdots$ (which is infinite if $S$ is), such that any element of $S$ is a member of the sequence.
	\end{fdef}

	One question that might immediately come to mind is: what is the difference between a computably enumerable set and an enumerable set? \\
	% Returning to the context of our study, define the following set of languages.

	Similar to how a NPDA is just an NFA with an additional stack to store information, a Turing machine is an NFA with an ``input tape'' -- this is an infinitely long string. If the input word is $w_1w_2 \cdots w_n$, this input tape is initially of the form $w_1 w_2 \cdots w_n b b b \cdots$, where $b$ is a special ``blank'' symbol. If we see the input $w_i$ when in state $q_j$, we do three things -- move to a state $q_k$, replace the symbol $w_i$ with some other symbol $X$, and move the tape left or right. Such a transition is represented by labelling the arrow from $q_j$ to $q_k$ as $w_i / X, R$ or $w_i / X, L$. If the machine ``halts'' (there are no moves possible) at a particular state, we accept if we are in an accepting state.\\
	So, let us now get to an example of a Turing machine, constructing that one recognizes the (context-free) language $\{ 0^n 1^n : n \ge 1 \}$. This Turing machine has tape alphabet $\{X,Y,0,1,b\}$.

	\begin{center}
	\begin{tikzpicture}[node distance=3cm]
		\node[state, initial] (q0) {$q_{0}$};
		\node[state, right of=q0] (q1) {$q_{1}$};
		\node[state, right of=q1] (q2) {$q_{2}$};
		\node[state, right of=q2] (q3) {$q_{3}$};
		\node[state, right of=q3] (q4) {$q_{4}$};
		\draw (q0) edge[above] node{$0/X,R$} (q1)
			  (q1) edge[loop above] node{$0/0,R$$Y/Y,R$} (q1)
			  (q1) edge[below] node{$1/Y,L$} (q2)
			  (q2) edge[bend left, below] node{$X/X,R$} (q0)
			  (q0) edge[bend right=60, below] node{$Y/Y,R$} (q3)
			  (q3) edge[loop above] node{$Y/Y,R$} (q4)
			  (q3) edge[above] node{$b/b,R$} (q4);
	\end{tikzpicture}
	\end{center}

	\begin{exercise}
		Construct a Turing machine that accepts
		\[ \{ L = a^nb^nc^n : n \ge 1 \}. \]
	\end{exercise}

	\begin{fdef}[Turing Machine]
		A Turing machine is a $7$-tuple $(Q,\Sigma,\Gamma,\delta,q_0,b,F)$, where
		\begin{enumerate}
			\item $Q$ is the finite set of states,
			\item $\Sigma \subseteq \Gamma \setminus \{b\}$ is the alphabet,
			\item $\Gamma$ is the tape alphabet,
			\item $\delta : Q \times \Gamma \to Q \times \Gamma \times \{L,R\}$ is the transition function,
			\item $q_0 \in Q$ is the start state,
			\item $b \in \Gamma$ is a special blank symbol, and
			\item $F \subseteq Q$ is the set of final states.
		\end{enumerate}
	\end{fdef}

	There are several simple variations of Turing machines:
	\begin{itemize}
		\item Two-way infinite tapes,
		\item Multiple tape heads,
		\item Non-deterministic Turing machines,
		\item An output tape where we can only move right.
	\end{itemize}
	It turns out that all of these are equivalent to the usual Turing machine.\\

	At any point of time, the Turing machine has a tape that contains a string of symbols with an infinite number of blanks on either side. Initially, this string is just the input, and the head is at the leftmost symbol.

	\begin{definition}[Instantaneous Description]
		An \emph{instantaneous description} of a Turing machine is a string of the form $\alpha q\beta$, where $\alpha,\beta \in \Gamma^*$ and $q \in Q$.
	\end{definition}
	What this represents is that $\alpha,\beta$ are on the tape with an infinite number of blanks on either side, and $q$, the state the automaton is at, is just before the position pointed at by the head.\\
	We further write that $\alpha q \beta \vdash \alpha' q' \beta'$ if a single step can take the first ID to the second.

	\begin{definition}
		A Turing machine is said to \emph{accept} the word $w$ if
		\[ q_0 w \vdash \cdots \vdash \alpha q_k\beta, \]
		$q_k \in F$, and there is no move possible from the final ID (it \emph{halts}).
	\end{definition}

	\begin{exercise}
		Construct a Turing machine that accepts
		\[ L = \{ ww : w \in \{a,b\}^+ \}. \]
	\end{exercise}

	In both DFAs and NPDAs, we had that the run time of the automaton is bounded above by some known quantity (the length of the word). In Turing machines however, this is not the case! A Turing machines is a decision procedure (outputting `yes' or `no') only if it halts for all inputs.\\
	This is referred to as a \emph{semi-decision procedure}.\\

	Consider Hilbert's tenth problem -- does a given polynomial (over possibly multiple variables) with integer coefficients have integer roots? Since it is possible to enumerate all possible integer tuples, it is possible to give a semi-decision procedure to solve this problem.\\
	It in fact turns out that this problem is undecidable, as shown by Martin Davis, Yuri Matiyasevich, Hilary Putnam, and Julia Robinson.\\

	% Suppose there is a \emph{partial} function $\N^k \to \N$, and we have $y = f(x_1,x_2,\ldots,x_k)$. Suppose we give the input as $x_1$ $0$s, followed by a $1$, then $x_2$ $0$s, and all the way till $x_k$ $0$s. Then, there exists a Turing machine that halts on this input (and does not halt on invalid outputs), and more importantly, the tape is just $y$ $0$s when it halts.

	Similar to how we had defined regular languages and context-free languages, we define the following class of languages.

	\begin{fdef}
		A language $L \subseteq \Sigma^*$ is said to be \emph{recursively enumerable} if it is recognized by some Turing machine.
	\end{fdef}
	An immediate question is: do there even exist languages that are not recursively enumerable? We shall answer this and deal with related questions in Subsection \ref{subsec: limits of computation}.

\subsection{Type-\texorpdfstring{0}{$0$} Grammars}

	Type-$0$ grammars, usually referred to as \emph{unrestricted grammars} are a far more powerful version of context-free grammars, with the difference being that the left-hand side of the rule can be a string instead of a single character. For example, if we have the rule $AB \to BA$, we can derive the string $ZBAXY$ from $ZABXY$.

	Consider the following grammar that recognizes the language
	\[ L = \{ a^nb^nc^n : n \ge 1 \}. \]
	\begin{align*}
		S &\to ABCS \mid ABCT_c \\
		CA &\to AC \\
		BA &\to AB \\
		CB &\to BC \\
		CT_c &\to T_cc \mid T_bc \\
		BT_b &\to T_bb \mid T_ab \\
		AT_a &\to T_aa \mid a.
	\end{align*}

	It turns out that Type-$0$ Grammars are equivalent to Turing machines!\\

\subsection{Computable functions}
	
	Turing machines are not just restricted to recognizing languages. The same framework may be used to do several things:
	\begin{itemize}
		\item First is just language recognition which we have seen.
		\item Second is computation. Given a ``simple'' function from $\N^k \to \N$, we can begin the input tape with the input values separated by $\#$s (to separate the input variables), and when the Turing machine halts, the tape has the output on it. This is easily extended to \emph{partial} functions, which need not be defined on all of $\N^k$, by taking the output as valid iff it halts on an accepting state. A function that is not partial is said to be \emph{total}. When a Turing machine is used in this manner, it is called a \emph{transducer}.
		\item Third, we have enumeration. The tape begins empty, and an enumeration of a (countable) language is output. For example, if the language is $\{0^n1^n : n \in \N\}$, the output is $01\#0011\#000111\#\cdots$ and the Turing machine never halts.
	\end{itemize}

	The second question presents an interesting question: what exactly does ``simple'' mean? More precisely, exactly which functions may be computed by Turing machines?\\

	This leads to the subject of recursive function theory.\\
	Before we move to the subject proper, let us define some functions and operators used.

	\begin{fdef}
		Define the \emph{primitive functions} as follows.
		\begin{enumerate}
			\item 
			Given $k,n \in \N$, the \emph{constant} function $C^k_n : \N^k \to \N$ is the constant function on $k$ variables defined by
			\[ C_n^k(x_1,\ldots,x_k) = n \]
			for all $x_1,\ldots,x_k \in \N$.

			\item
			The \emph{successor} function $S: \N \to \N$ is defined by
			\[ S(x) = x+1 \]
			for all $x \in \N$.

			\item
			Given $k,i \in \N$ with $i \le k$, the \emph{projection} function $P_i^k : \N^k \to \N$ is defined by
			\[ P_i^k(x_1,\ldots,x_k) = x_i \]
			for all $x_1,\ldots,x_n \in \N$.
		\end{enumerate}

		Further define the following operators.
		\begin{enumerate}
			\item
			The \emph{composition} operator is defined as follows.
			Given a function $h: \N^m \to \N$ and $m$ functions $g_1,\ldots,g_m : \N^k \to \N$, define the function
			\[ (h\circ(g_1,\ldots,g_m))(x_1,\ldots,x_k) = f(g_1(x_1,\ldots,x_k),\ldots,g_m(x_1,\ldots,x_k)) \]
			for all $x_1,\ldots,x_k \in \N$.

			\item
			The \emph{primitive recursion} operator is defined as follows.
			Given $k \in \N$, $g : \N^{k-1} \to \N$, and $h: \N^{k+1} \to \N$, define the function $\rho(g,h) : \N^{k} \to \N$ by
			\[ (\rho(g,h))(x_1,x_2,\ldots,x_k) = \begin{cases} g(x_2,\ldots,x_k), & x_1 = 0, \\ h(x_1-1,g(x_1-1,x_2,x_3,\ldots,x_n),x_2,x_3,\ldots,x_n), & \text{otherwise.} \end{cases} \]

			\item
			The \emph{minimization} operator is defined as follows. Given $k\in\N$, $f:\N^{k+1} \to \N$, the function $\mu(f) : \N^k \to \N$ is defined by
			\[ (\mu(f))(x_1,\ldots,x_k) = \min \{ z : f(z,x_1,\ldots,x_k) = 0 \}. \]
			Note that the minimization operator need not be well-defined for a given $f$ (the value of the function may be non-zero for all $z$). So, $\mu(f)$ is a partial function.
		\end{enumerate}
	\end{fdef}

	Using the above, we may define several classes of ``computable'' functions.

	\begin{fdef}
		The class of \emph{primitive recursive functions} is the smallest class of total functions that contains the primitive functions and is closed under composition and primitive recursion.\\
		The class of \emph{general recursive functions} is the smallest class of functions (total or partial) that contains the primitive functions and is closed under composition, primitive recursion, and minimization.\\
		The class of \emph{general recursive functions} is the smallest class of total functions that contains the primitive functions and is closed under composition, primitive recursion, and minimization.
	\end{fdef}

	For example, the function $f : (x,y) \mapsto x+y$ is defined by
	\[ f = \rho(P_2^2, S \circ P_2^3). \]

\subsection{Recursively enumerable and recursive languages}

	Recall that recursively enumerable languages are those languages recognized by a Turing machine.

	\begin{prop}
		\label{prop: exist non rec en langs}
		There exist non-recursively enumerable languages over any alphabet $\Sigma$.
	\end{prop}
	\begin{proof}
		Clearly, it suffices to consider the case where $|\Sigma| = 1$, so let $\Sigma = a$. Observe that the set $\mathcal{P}(a^*)$ is not countable. Any Turing machine can be thought of as a string over $\{0,1\}$, namely as the concatenation of the strings $0^i10^j10^k10^l10^s$, where for each transition from $q_i$ to $q_j$ with the lab $k/l,s$ (numbering the tape symbols and alphabet symbols ahead of time), with the transitions separated by $11$s. The set of such strings is a subset of $\{0,1\}^*$, so it (and thus the set of all Turing machines) is countable! The required follows.
	\end{proof}

	These limits however, are only useful to us in the sense that we would like to know whether a given problem is within the limits or not. Indeed, the above argument may be used to show that there exist languages that cannot be recognized by any program (in C, say) either, because any program is a finite string of ASCII characters. Let us study our little nook of recursively enumerable languages a little more before moving to the limits. In fact, a program is weaker than a Turing machine since it has a finite amount of memory.

	\begin{definition}[Algorithm]
		An \emph{algorithm} is a Turing machine that halts for any input.\\
		A language recognized by an algorithm is said to be a \emph{recursive language}.
	\end{definition}

	Nearly every language one might run into is recursive.

	\begin{ftheo}
		The class of recursively enumerable languages is closed under union, intersection, concatenation and the Kleene star.\\
		The class of recursive languages is closed under union, intersection, concatenation, the Kleene star, and complementation.
	\end{ftheo}
	\begin{proof}
		Let us begin by showing the closure of recursively enumerable languages under various operations.
		\begin{enumerate}
			\item Union. Create a two-tape Turing machine, with the two tapes simulating the Turing machines for each of the languages. Accept when either of the two simulations accepts -- note that we forcibly halt the running of the other Turing machine after one accepts.
			\item Intersection. Again, create a two-tape Turing machine, with each of the two tapes simulating the Turing machines for each of the languages. Accept when both simulations accept.
			\item Concatenation. Create a two-tape Turing machine as follows. Given input $w$, non-deterministically guess a break as $w=xy$, move $y$ to the second tape, and run the second Turing machine on $y$. Accept if both simulations accept.
			\item Kleene star.The idea of this is identical to that of concatenation, except that we guess multiple breaks instead of just one.
		\end{enumerate}
		Now, let us move on to the closure of recursive languages.
		\begin{enumerate}
			\item The construction for union and intersection is identical to that for recursively enumerable languages. Since both Turing machines halt for any input, so does the new Turing machine.
			\item The construction for concatenation and Kleene star is identical as well. % systematically guess all breaks to destroy non-determinism? what's wrong with having a NTM?
			\item Complementation. Let the original Turing machine run and accept iff it halts on a non-accepting state.
		\end{enumerate}
	\end{proof}

\subsection{Limits of computation}
\label{subsec: limits of computation}

	A common theme of questioning is asking whether a given ``object'' has a certain ``property''. For example, given a graph $G$ and an input number $k$, one may ask whether $G$ has a clique of size $k$. In such a problem, the inputs $(G,k)$ is referred to as an \emph{instance} of the problem. Any instance of the problem may be encoded as a word over some alphabet, say $\{0,1\}$, and based on this one can ask the question whether it is possible to construct a Turing machine that recognizes the words corresponding to all positive instances of the problem.

	\begin{fdef}
		A problem is \emph{decidable} if there is an algorithm to answer it. Otherwise, the problem is said to be \emph{undecidable}.
	\end{fdef}

	As seen in \Cref{prop: exist non rec en langs}, not every language is recognizable by a Turing machine.\\
	In fact, one may use a diagonalization argument to construct a non-recursively enumerable language as
	\[ L_d = \{ w : w \text{ is the $i$th string but is not recognized by the $i$th TM } \}. \]
	One may also consider the language $L_d'$ wherein instead of considering all strings, we only consider those strings that are valid TM codes (and reject everything else). This is defined by the slightly simpler-to-state
	\[ L_d' = \{ w : \text{if } w \text{ is a TM code, it does not recognize itself} \}. \]
	However, this is hardly interesting outside of the fact that it exists. Do there exist more useful undecidable languages?\\

	Before moving to this, let us give an example of a language that is recursively enumerable but not recursive. Recall from earlier that any Turing machine may be translated to a string over $\{0,1\}$. Consider the \emph{universal Turing machine} that takes as input a Turing machine $M$ and a binary string $w$, and accepts iff $M$ recognizes $w$. $M$ and $w$ can be separated by $111$ in the input. If the input is not of this desired form, we immediately reject. It is not too difficult to construct a Turing machine that recognizes this language -- we maintain one tape for the initial input, one for the tape of (a simulation of) $M$, and a third to store the state of $M$.\\
	We claim that the language $L_u$ recognized by the above Turing machine is undecidable. Suppose instead that it was recursive, and let $U$ be an algorithm that recognizes it. Given an input $w$, we may then check if it is in $L_d'$ as follows.
	\begin{enumerate}
		\item Check if $w$ is a valid TM code. If it is not, accept.
		\item Feed $w111w$ into $U$.
		\item Reject if $U$ halts on an accepting state and accept otherwise.
	\end{enumerate}
	This definitely halts (because $U$ is an algorithm), so we have an algorithm for $L_d'$, which is a contradiction!

	\begin{definition}[Property]
		A set of languages is called a \emph{property} of languages. If a language belongs to a certain property, it is said to have that property.
	\end{definition}
	Given a property $P$, let $L_P$ be the language comprising TM codes of TMs $M$ such that $L(M)$ has $P$.\\
	Two obvious \emph{trivial} properties are:
	\begin{enumerate}
		\item The ``always false'' property, which is the empty set.
		\item The ``always true'' property, which has every language.
	\end{enumerate}
	These are clearly decidable. Very surprisingly, these are the \emph{only} decidable properties!

	\begin{ftheo}[Rice's Theorem]
		For any non-trivial property $P$ that has a recursively enumerable language, $L_P$ is undecidable.
	\end{ftheo}

	Let us give some more setup before proving this result.

	\begin{fdef}[Reduction]
		A \emph{reduction} from language $L$ to $L'$ is an algorithm that given a string $w$, converts it to a string $x$ such that $x \in L'$ iff $w \in L$.
	\end{fdef}

	If a language $L'$ is undecidable and we have a reduction from $L$ to $L'$, then the two algorithms together give an algorithm for $L$! That is, if there is a reduction from $L'$ to $L$ and $L$ is decidable, then so is $L'$. The contrapositive of this is that if we have a reduction from $L'$ to $L$ and $L'$ is undecidable, then so is $L$. \\
	Observe that our earlier ``reduction'' of $L_d'$ to $L_u$ is not in fact a reduction in the sense of the above definition. Indeed, we had complemented the result of $U$ which is not allowed by the above definition.

	\begin{proof}[Proof of Rice's Theorem]
		Let us assume that $\emptyset$ does not have $P$. If it does, consider the complement of $P$ instead -- this works out because the class of recursive languages is closed under complementation.\\
		We shall reduce $L_u$ to $L_P$. Given a word $w$ and Turing machine code $M$, we must generate a Turing machine code $M'$ such that $M$ recognizes $w$ iff $L(M')$ has $P$. \\
		Let $L$ be a recursively enumerable language which has property $P$ and $M_L$ a TM that recognizes $L$.
		When given input $x$, $M'$ works as follows:
		\begin{enumerate}
			\item It simulates $M$ on $w$.
			\item If accepted, it begins simulating $M_L$ on $x$.
			\item Accept iff $M_L$ accepts $x$ in the second step.
		\end{enumerate}
		Why does this work?
		\begin{itemize}
			\item If $M$ does not recognize $w$, then we never move past the first step, so the language of $M'$ is $\emptyset$, which does not have $P$.
			\item If $M$ recognizes $w$, then $M'$ ends up accepting a word $x$ iff $M_L$ accepts $x$, that is, $x \in L$. As a result, if $M$ recognizes $w$, the language of $M'$ is just $L$, which does have $P$.
		\end{itemize}
		The Turing machine is just a filter that outputs a fixed language with $P$ if $M$ recognizes $w$ and $\emptyset$ otherwise.\\
		The existence of the reduction implies that $L_P$ is undecidable, completing the proof.
	\end{proof}

	The important point to note is that while the Turing machine $M'$ itself may not be algorithm (it is not), the \emph{creation} of $M'$ from $M$ and $w$ is.

	While this is all good, we are yet to get an undecidable language that is not tied to some sort of Turing machine machinery! To give a more general example, consider the following.

	\begin{fprob}[Post's Correspondence Problem]
		An instance of PCP is two lists $(w_1,w_2,\ldots,w_n)$ and $(x_1,x_2,\ldots,x_n)$ of strings over some alphabet $\Sigma$. The answer to this instance is yes iff there exists some non-empty sequence $i_1,i_2,\ldots,i_k$ of indices in $[n]$ such that $w_{i_1} w_{i_2} \cdots w_{i_k} = x_{i_1} x_{i_2} \cdots x_{i_k}$.
	\end{fprob}

	We also present a slightly modified version of the above for the sake of proving undecidability.

	\begin{problem}[Modified Post's Correspondence Problem]
		An instance of MPCP is two lists $(w_1,w_2,\ldots,w_n)$ and $(x_1,x_2,\ldots,x_n)$ of strings over some alphabet $\Sigma$. The answer to this instance is yes iff there exists some non-empty sequence $i_1,i_2,\ldots,i_k$ of indices in $[n]$ such that $w_{i_1} w_{i_2} \cdots w_{i_k} = x_{i_1} x_{i_2} \cdots x_{i_k}$ and $i_1 = 1$.
	\end{problem}

	To prove undecidability, we shall give a reduction from $L_u$ to PCP. This shall be done by reducing it to MPCP, then reducing MPCP to PCP. ``Concatenating'' the two reductions yields a reduction from $L_u$ to PCP.

	\begin{theorem}
		MPCP is reducible to PCP.
	\end{theorem}
	\begin{proof}
		Consider an instance $(w_1,\ldots,w_n)$ and $(x_1,\ldots,x_n)$ of MPCP. For each string $v$, refer to the $i$th character of $v$ as $v_i$. The corresponding instance of PCP we use is of the form $(w_0',w_1',\ldots,w_n',\$)$ and $(x_0',x_1',\ldots,x_n',*\$)$ where
		\[ w_0' = *(w_1)_1*(w_1)_2*\cdots*(w_1)_{\ell(w_1)}* \text{ and } x_0' = *(x_1)_1*(x_1)_2*\cdots*(x_1)_{\ell(x_1)}. \]
		For $i \ge 1$,
		\[ w_i' = (w_i)_1*(w_i)_2*\cdots*(w_i)_{\ell(w_i)}* \text{ and } x_0' = *(x_i)_1*(x_i)_2*\cdots*(x_i)_{\ell(x_i)}. \]
		If the MPCP instance is positive, it is clear that so is the PCP instance -- we just need to insert $*$s everywhere and add a $\$$ at the end. If the PCP instance is positive, then observe that the sequence must begin with $0$. Indeed, if it were to start with any other index $i \ne 0$, the first character of the $w_i'$ would be $*$, but not that of the $x_i'$. That is, it forces the $w_i$ corresponding to the string to be $w_1$, which is exactly what is required by MPCP.
	\end{proof}

	\begin{ftheo}
		PCP is undecidable.
	\end{ftheo}
	\begin{proof}
		We shall give a reduction from $L_u$ to MPCP. Suppose we are given a Turing machine $M$ and a word $w$. Assume that $M$ has a semi-infinite tape. The MPCP instance will simulate the instantaneous descriptions of the running of the Turing machine on $w$.\\
		The list of pairs of strings $(w_i,x_i)$ is as follows.
		\begin{enumerate}
			\item $(\#,\#q_0w\#)$. This is the first string (forced by MPCP to start), wherein the second string starts off with the initial ID. $q_0$ is the start state of $M$.
			\item $(\#,\#)$. This ends the ID currently being read.
			\item $(X,X)$ for any tape symbol $X$ of $M$. This is the copying of a tape symbol from the previous ID to the next.
			\item $(qX,Yp)$ for each transition $\delta(q,X) = (p,Y,R)$. This represents $q$ seeing the symbol $X$ and moving to the right, replacing $X$ with $Y$.
			\item $(ZqX,pZY)$ for each transition $\delta(q,X) = (p,Y,L)$ and any tape symbol $Z$. To move to the left, we also have to take into account the previous symbol and shift it to the right.
			\item $(q\#,Yp\#)$ for each transition $\delta(q,B) = (p,Y,R)$. It is possible to replace a blank symbol immediately after the very end of the string and move to the right.
			\item $(Zq\#,pZY\#)$ for each transition $\delta(q,B) = (p,Y,R)$. It is possible to replace a blank symbol immediately after the very end of the string and move to the left.
		\end{enumerate}
		The idea is as follows: both strings attempt to create the list of the IDs separated by $\#$s, except that the second string is ahead by one ID. To ensure string equality, the first string must copy the previous ID in the second string, and we can change the second string appropriately to convey that it is an ID.\\
		The role of the $w_i$ is just to ``read'' the previous ID.
	\end{proof}